EM_superinfection_anym <- function(n,vecn,alpha) {#
  ################## inputs #############################
  ## n = number of samples per person, each with single winner, #
  ##    will be 2 or 3 or larger#
  ## vecn = number of persons with 1, 2, ... n observed infections#
  ## alpha = exponential parameter#
  if (length(vecn) > n) {print("error: more observed infections than samples")#
    break}#
  N <- sum(vecn)#
  ## N2 <- vecn[2] ; if (n>2) {N3 <- vecn[3]}#
  ################## initialize #############################
  ## start with grid search for lambda that satisfies E(K)#
  ## set reasonable range for potential values of lambda#
  ## these endpoints give range between 1 and 2 infections pp#
  ##@ lammin <- .01  ;  lammax <- 1.6#
  ## but use wider range so can explore extreme cases#
  lammin <- .01  ;  lammax <- 4#
  lamtry <- seq(lammin,lammax,by=0.001)#
  expectR <- (N+vecn[2])/N  #
  explam <- function(lam) { lam/(1-exp(-lam)) }#
  ## see which values of lam give us expectK close to observed#
  lamtest <- explam(lam=lamtry)#
  lamcurr <- lamtry[abs(lamtest-expectR)==min(abs(lamtest-expectR))]#
  ## need two inital values of lambda since loop depends on#
  ##   the distance between successive estimates from M step#
  lam <- lamcurr + .5#
  ## max r should be infty but just need large enough#
  ##   so that its probability gets small, # infections wont be huge#
  maxr <- 12#
  seqr <- 1:maxr ; matr <- seqr%*%t(rep(1,n))#
  #################### start loop ############################
  ntries <- 0#
  ## do loop no more than 50 times and stop if estimates close#
  while (abs(lam-lamcurr) > .001 & ntries < 50) {#
    ntries <- ntries + 1#
    #################### E step ###############################
    ## first time use initialized lambda, o.w. from end of M step#
    lam <- lamcurr  #
    ## this is the new numerator using the exponential decay#
    ##   but if alpha = 0 simplifies to evenness assumption#
    ## start with the conditional probabilities of r0 given r and n true#
    ## make all possibilies of true and observed numbers of strains#
    matprobs <- matrix(0,nrow=maxr,ncol=n)#
    dimnames(matprobs) <- list(paste('r',1:maxr,sep=''),paste('r0',1:n,sep=''))#
    rr <- 1 #
    for (indr in 1:maxr) {  ## loop over number of possible true strains#
      ## peq is the probability of each strain from a single sample#
      seqrloop <- 1:indr #
      peq <- exp(-seqrloop*alpha) / sum(exp(-seqrloop*alpha))#
      ## r0 must be no greater than n samples, no greater than r true strains #
      for (indr0 in 1:min(indr,n)) {  ## loop over number of observed strains#
        ## for each iteration of this loop, #
        ##   the conditional probabilities p(r0|r,n) should add to 1#
        matind <- mkmatind(r=indr,r0=indr0) ; di <- max(1,dim(matind)[1])#
        matposs <- mkmatposs(r0=indr0,n=n) ; dp <- max(1,dim(matposs)[1])#
        ## now need to make one row for every combination or matind and matposs#
        ## combination will be all possible ways to observe indr0 strains#
        ## bigind gives which strains observed#
        bigind <- matrix(as.vector(t(matind)),nrow=di*dp,ncol=indr0,byrow=T)#
        ## bigposs says how many of each of those named in bigind#
        if (dp == 1 ) {   ## placeholder only need if r0=1#
          bigposs <- matrix(matposs,nrow=di,ncol=indr0,byrow=T) #
        }#
        if (dp > 1 ) {#
          bigposs <- matrix(matposs[1,],nrow=di,ncol=indr0,byrow=T)#
          for (pp in 2:dp) {  addon <- matrix(matposs[pp,],nrow=di,ncol=indr0,byrow=T)#
             bigposs <- rbind(bigposs,addon) } }#
        ## the product of each row of pmat is the probability of that combination#
        ##   of strains and numbers of strains making up the observed number#
        ## these first part is the probabilities in order#
        matpeq <- matrix(peq[bigind],nrow=di*dp,ncol=indr0,byrow=F)#
        ## next exponentiate them for the number of times drawn#
        pmat <- (matpeq)^bigposs #
        ## and compute probability for this combo as the product#
        jointprobs <- apply(pmat,1,prod)#
        matprobs[indr,indr0] <- sum(jointprobs)#
      } ## end loop over r0#
    }  ## end loop over r#
    ## now finishing up E step#
    ## recall matprobs is f(r0|r,n)#
    ## so tosum is f(r0,r|n) = f(r0|r,n) * f(r)#
    tosum <- matprobs * (lam^matr / factorial(matr))    #
    ## and condprobs is f(r|r0,n) = f(r0,r|n) / f(r0|n)#
    ##   where f(r0|n) = sum over r of f(r0,r|n) using colSums#
    condprobs <- tosum/(rep(1,maxr)%*%t(colSums(tosum)))#
    #################### M step ###############################
    ## to solve this, make left side equal to right side by grid search#
    ## the left side of the equation uses the condition probs#
    ##    and the right side has to do with lambda#
    addup <- colSums(matr*condprobs)#
    lside <- sum(vecn*addup)#
    rside <- function(lam,N) { N*lam*exp(lam)/(exp(lam)-1) }#
    lamtest <- rside(lam=lamtry,N=N)#
    ## once you compute the right side of the equation at all these values#
    ##    then pick the one that makes left and ride sides closest#
    lamcurr <- lamtry[abs(lamtest-lside)==min(abs(lamtest-lside))]#
    cat("ntries=",ntries,'\n')#
    print(round(condprobs[1:4,],2)) ; print(lamcurr)#
  }  ## end while loop#
  ## compute expected infection pp and probability of superinf#
  expectr <- lamcurr/(1-exp(-lamcurr))#
  ## p(super) = p(r>=2) = 1 - p(r=1)#
  psuper <- 1 - lamcurr/(exp(lamcurr)-1)#
  list(lamcurr=lamcurr,expectr=expectr,psuper=psuper,condprobs=condprobs)  #
} ## end of function#
## do an example from HCV paper#
 seqq <- seq(0,3,.25)#
 pest <- seqq#
 for (aa in 1:length(seqq)) #
 {#
 pest[aa] <- EM_superinfection_anym(n=2,vecn=c(150,6),alpha=seqq[aa])$psuper   #
 }#
 ## do an example from Redd survey#
 N2=c(1,3,1,13,1,2,2,3,2,7,12,1,3,2,10) #
 N=c(13,78,16,58,8,14,46,145,147,149,56,7,44,130,145)#
 Redd_data=cbind(N-N2,N2)#
#
 pest <- N1#
#
 for (i in 1:length(N1)) #
 {#
 pest[i] <- EM_superinfection_anym(n=2,vecn=Redd_data[i,],alpha=2)$psuper #
 }
EM_superinfection_anym <- function(n,vecn,alpha) {#
  ################## inputs #############################
  ## n = number of samples per person, each with single winner, #
  ##    will be 2 or 3 or larger#
  ## vecn = number of persons with 1, 2, ... n observed infections#
  ## alpha = exponential parameter#
  if (length(vecn) > n) {print("error: more observed infections than samples")#
    break}#
  N <- sum(vecn)#
  ## N2 <- vecn[2] ; if (n>2) {N3 <- vecn[3]}#
  ################## initialize #############################
  ## start with grid search for lambda that satisfies E(K)#
  ## set reasonable range for potential values of lambda#
  ## these endpoints give range between 1 and 2 infections pp#
  ##@ lammin <- .01  ;  lammax <- 1.6#
  ## but use wider range so can explore extreme cases#
  lammin <- .01  ;  lammax <- 4#
  lamtry <- seq(lammin,lammax,by=0.001)#
  expectR <- (N+vecn[2])/N  #
  explam <- function(lam) { lam/(1-exp(-lam)) }#
  ## see which values of lam give us expectK close to observed#
  lamtest <- explam(lam=lamtry)#
  lamcurr <- lamtry[abs(lamtest-expectR)==min(abs(lamtest-expectR))]#
  ## need two inital values of lambda since loop depends on#
  ##   the distance between successive estimates from M step#
  lam <- lamcurr + .5#
  ## max r should be infty but just need large enough#
  ##   so that its probability gets small, # infections wont be huge#
  maxr <- 12#
  seqr <- 1:maxr ; matr <- seqr%*%t(rep(1,n))#
  #################### start loop ############################
  ntries <- 0#
  ## do loop no more than 50 times and stop if estimates close#
  while (abs(lam-lamcurr) > .001 & ntries < 50) {#
    ntries <- ntries + 1#
    #################### E step ###############################
    ## first time use initialized lambda, o.w. from end of M step#
    lam <- lamcurr  #
    ## this is the new numerator using the exponential decay#
    ##   but if alpha = 0 simplifies to evenness assumption#
    ## start with the conditional probabilities of r0 given r and n true#
    ## make all possibilies of true and observed numbers of strains#
    matprobs <- matrix(0,nrow=maxr,ncol=n)#
    dimnames(matprobs) <- list(paste('r',1:maxr,sep=''),paste('r0',1:n,sep=''))#
    rr <- 1 #
    for (indr in 1:maxr) {  ## loop over number of possible true strains#
      ## peq is the probability of each strain from a single sample#
      seqrloop <- 1:indr #
      peq <- exp(-seqrloop*alpha) / sum(exp(-seqrloop*alpha))#
      ## r0 must be no greater than n samples, no greater than r true strains #
      for (indr0 in 1:min(indr,n)) {  ## loop over number of observed strains#
        ## for each iteration of this loop, #
        ##   the conditional probabilities p(r0|r,n) should add to 1#
        matind <- mkmatind(r=indr,r0=indr0) ; di <- max(1,dim(matind)[1])#
        matposs <- mkmatposs(r0=indr0,n=n) ; dp <- max(1,dim(matposs)[1])#
        ## now need to make one row for every combination or matind and matposs#
        ## combination will be all possible ways to observe indr0 strains#
        ## bigind gives which strains observed#
        bigind <- matrix(as.vector(t(matind)),nrow=di*dp,ncol=indr0,byrow=T)#
        ## bigposs says how many of each of those named in bigind#
        if (dp == 1 ) {   ## placeholder only need if r0=1#
          bigposs <- matrix(matposs,nrow=di,ncol=indr0,byrow=T) #
        }#
        if (dp > 1 ) {#
          bigposs <- matrix(matposs[1,],nrow=di,ncol=indr0,byrow=T)#
          for (pp in 2:dp) {  addon <- matrix(matposs[pp,],nrow=di,ncol=indr0,byrow=T)#
             bigposs <- rbind(bigposs,addon) } }#
        ## the product of each row of pmat is the probability of that combination#
        ##   of strains and numbers of strains making up the observed number#
        ## these first part is the probabilities in order#
        matpeq <- matrix(peq[bigind],nrow=di*dp,ncol=indr0,byrow=F)#
        ## next exponentiate them for the number of times drawn#
        pmat <- (matpeq)^bigposs #
        ## and compute probability for this combo as the product#
        jointprobs <- apply(pmat,1,prod)#
        matprobs[indr,indr0] <- sum(jointprobs)#
      } ## end loop over r0#
    }  ## end loop over r#
    ## now finishing up E step#
    ## recall matprobs is f(r0|r,n)#
    ## so tosum is f(r0,r|n) = f(r0|r,n) * f(r)#
    tosum <- matprobs * (lam^matr / factorial(matr))    #
    ## and condprobs is f(r|r0,n) = f(r0,r|n) / f(r0|n)#
    ##   where f(r0|n) = sum over r of f(r0,r|n) using colSums#
    condprobs <- tosum/(rep(1,maxr)%*%t(colSums(tosum)))#
    #################### M step ###############################
    ## to solve this, make left side equal to right side by grid search#
    ## the left side of the equation uses the condition probs#
    ##    and the right side has to do with lambda#
    addup <- colSums(matr*condprobs)#
    lside <- sum(vecn*addup)#
    rside <- function(lam,N) { N*lam*exp(lam)/(exp(lam)-1) }#
    lamtest <- rside(lam=lamtry,N=N)#
    ## once you compute the right side of the equation at all these values#
    ##    then pick the one that makes left and ride sides closest#
    lamcurr <- lamtry[abs(lamtest-lside)==min(abs(lamtest-lside))]#
    cat("ntries=",ntries,'\n')#
    print(round(condprobs[1:4,],2)) ; print(lamcurr)#
  }  ## end while loop#
  ## compute expected infection pp and probability of superinf#
  expectr <- lamcurr/(1-exp(-lamcurr))#
  ## p(super) = p(r>=2) = 1 - p(r=1)#
  psuper <- 1 - lamcurr/(exp(lamcurr)-1)#
  list(lamcurr=lamcurr,expectr=expectr,psuper=psuper,condprobs=condprobs)  #
} ## end of function
seqq <- seq(0,3,.25)#
 pest <- seqq#
 for (aa in 1:length(seqq)) #
 {#
 pest[aa] <- EM_superinfection_anym(n=2,vecn=c(150,6),alpha=seqq[aa])$psuper   #
 }
source('EM_superinfection_anym.R')
lamck <- seq(.005,1,.005)#
pck <- 1 - lamck/(exp(lamck)-1)#
superuse <- c(.01,.02,.05,.1,.2,.3)  ## superinfection rates#
lamuse <- approx(x=pck,y=lamck,xout=superuse)$y
source('mk_matind.R') # all possible combinations that lead to Robs#
source('mk_matposs.R') # the number of ways to split up n samples to get
EM_superinfection_anym <- function(n,vecn,alpha) {#
  ################## inputs #############################
  ## n = number of samples per person, each with single winner, #
  ##    will be 2 or 3 or larger#
  ## vecn = number of persons with 1, 2, ... n observed infections#
  ## alpha = exponential parameter#
  if (length(vecn) > n) {print("error: more observed infections than samples")#
    break}#
  N <- sum(vecn)#
  ## N2 <- vecn[2] ; if (n>2) {N3 <- vecn[3]}#
  ################## initialize #############################
  ## start with grid search for lambda that satisfies E(K)#
  ## set reasonable range for potential values of lambda#
  ## these endpoints give range between 1 and 2 infections pp#
  ##@ lammin <- .01  ;  lammax <- 1.6#
  ## but use wider range so can explore extreme cases#
  lammin <- .01  ;  lammax <- 4#
  lamtry <- seq(lammin,lammax,by=0.001)#
  expectR <- (N+vecn[2])/N  #
  explam <- function(lam) { lam/(1-exp(-lam)) }#
  ## see which values of lam give us expectK close to observed#
  lamtest <- explam(lam=lamtry)#
  lamcurr <- lamtry[abs(lamtest-expectR)==min(abs(lamtest-expectR))]#
  ## need two inital values of lambda since loop depends on#
  ##   the distance between successive estimates from M step#
  lam <- lamcurr + .5#
  ## max r should be infty but just need large enough#
  ##   so that its probability gets small, # infections wont be huge#
  maxr <- 12#
  seqr <- 1:maxr ; matr <- seqr%*%t(rep(1,n))#
  #################### start loop ############################
  ntries <- 0#
  ## do loop no more than 50 times and stop if estimates close#
  while (abs(lam-lamcurr) > .001 & ntries < 50) {#
    ntries <- ntries + 1#
    #################### E step ###############################
    ## first time use initialized lambda, o.w. from end of M step#
    lam <- lamcurr  #
    ## this is the new numerator using the exponential decay#
    ##   but if alpha = 0 simplifies to evenness assumption#
    ## start with the conditional probabilities of r0 given r and n true#
    ## make all possibilies of true and observed numbers of strains#
    matprobs <- matrix(0,nrow=maxr,ncol=n)#
    dimnames(matprobs) <- list(paste('r',1:maxr,sep=''),paste('r0',1:n,sep=''))#
    rr <- 1 #
    for (indr in 1:maxr) {  ## loop over number of possible true strains#
      ## peq is the probability of each strain from a single sample#
      seqrloop <- 1:indr #
      peq <- exp(-seqrloop*alpha) / sum(exp(-seqrloop*alpha))#
      ## r0 must be no greater than n samples, no greater than r true strains #
      for (indr0 in 1:min(indr,n)) {  ## loop over number of observed strains#
        ## for each iteration of this loop, #
        ##   the conditional probabilities p(r0|r,n) should add to 1#
        matind <- mkmatind(r=indr,r0=indr0) ; di <- max(1,dim(matind)[1])#
        matposs <- mkmatposs(r0=indr0,n=n) ; dp <- max(1,dim(matposs)[1])#
        ## now need to make one row for every combination or matind and matposs#
        ## combination will be all possible ways to observe indr0 strains#
        ## bigind gives which strains observed#
        bigind <- matrix(as.vector(t(matind)),nrow=di*dp,ncol=indr0,byrow=T)#
        ## bigposs says how many of each of those named in bigind#
        if (dp == 1 ) {   ## placeholder only need if r0=1#
          bigposs <- matrix(matposs,nrow=di,ncol=indr0,byrow=T) #
        }#
        if (dp > 1 ) {#
          bigposs <- matrix(matposs[1,],nrow=di,ncol=indr0,byrow=T)#
          for (pp in 2:dp) {  addon <- matrix(matposs[pp,],nrow=di,ncol=indr0,byrow=T)#
             bigposs <- rbind(bigposs,addon) } }#
        ## the product of each row of pmat is the probability of that combination#
        ##   of strains and numbers of strains making up the observed number#
        ## these first part is the probabilities in order#
        matpeq <- matrix(peq[bigind],nrow=di*dp,ncol=indr0,byrow=F)#
        ## next exponentiate them for the number of times drawn#
        pmat <- (matpeq)^bigposs #
        ## and compute probability for this combo as the product#
        jointprobs <- apply(pmat,1,prod)#
        matprobs[indr,indr0] <- sum(jointprobs)#
      } ## end loop over r0#
    }  ## end loop over r#
    ## now finishing up E step#
    ## recall matprobs is f(r0|r,n)#
    ## so tosum is f(r0,r|n) = f(r0|r,n) * f(r)#
    tosum <- matprobs * (lam^matr / factorial(matr))    #
    ## and condprobs is f(r|r0,n) = f(r0,r|n) / f(r0|n)#
    ##   where f(r0|n) = sum over r of f(r0,r|n) using colSums#
    condprobs <- tosum/(rep(1,maxr)%*%t(colSums(tosum)))#
    #################### M step ###############################
    ## to solve this, make left side equal to right side by grid search#
    ## the left side of the equation uses the condition probs#
    ##    and the right side has to do with lambda#
    addup <- colSums(matr*condprobs)#
    lside <- sum(vecn*addup)#
    rside <- function(lam,N) { N*lam*exp(lam)/(exp(lam)-1) }#
    lamtest <- rside(lam=lamtry,N=N)#
    ## once you compute the right side of the equation at all these values#
    ##    then pick the one that makes left and ride sides closest#
    lamcurr <- lamtry[abs(lamtest-lside)==min(abs(lamtest-lside))]#
    cat("ntries=",ntries,'\n')#
    print(round(condprobs[1:4,],2)) ; print(lamcurr)#
  }  ## end while loop#
  ## compute expected infection pp and probability of superinf#
  expectr <- lamcurr/(1-exp(-lamcurr))#
  ## p(super) = p(r>=2) = 1 - p(r=1)#
  psuper <- 1 - lamcurr/(exp(lamcurr)-1)#
  list(lamcurr=lamcurr,expectr=expectr,psuper=psuper,condprobs=condprobs)  #
} ## end of function
vecn = c(100,30,3)
N <- sum(vecn)
lammin <- .01  ;  lammax <- 4#
  lamtry <- seq(lammin,lammax,by=0.001)
lamtry
mean(vecn)
expectR <- (N+vecn[2])/N
expectR
mean(vecn)/N
vecn[1]+2*vecn[2]+3*vecn[3]
169/N
explam <- function(lam) { lam/(1-exp(-lam)) }
lamtest <- explam(lam=lamtry)
lamcurr <- lamtry[abs(lamtest-expectR)==min(abs(lamtest-expectR))]
lamcurr
sum(range(length))
range(length(vecn))
1:length(vecn)
sum((1:length(vecn))*vecn)
sum((1:length(vecn))*vecn)/N
lammin <- .01  ;  lammax <- 4  #start with unrealistically wide range of lambdas#
  lamtry <- seq(lammin,lammax,by=0.001) #make a huge list of lambdas#
  expectR <- sum((1:length(vecn))*vecn)/N #use naive MLE at first order #
  lamtest <- explam(lam=lamtry) #use TP distribution#
  lamcurr <- lamtry[abs(lamtest-expectR)==min(abs(lamtest-expectR))] #best lambda given <R>#
  lam <- lamcurr + 0.5   # 2nd estimate to compute initial error #
  maxr <- 12 #we are interested in relatively small richnesses in this paper#
  seqr <- 1:maxr ; matr <- seqr%*%t(rep(1,n))
n=3
lammin <- .01  ;  lammax <- 4  #start with unrealistically wide range of lambdas#
  lamtry <- seq(lammin,lammax,by=0.001) #make a huge list of lambdas#
  expectR <- sum((1:length(vecn))*vecn)/N #use naive MLE at first order #
  lamtest <- explam(lam=lamtry) #use TP distribution#
  lamcurr <- lamtry[abs(lamtest-expectR)==min(abs(lamtest-expectR))] #best lambda given <R>#
  lam <- lamcurr + 0.5   # 2nd estimate to compute initial error #
  maxr <- 12 #we are interested in relatively small richnesses in this paper#
  seqr <- 1:maxr ; matr <- seqr%*%t(rep(1,n))
matr
ntries <- ntries + 1#
    #################### E step ###############################
    lam <- lamcurr  #update lam with new value from M step#
    ## start with the conditional probabilities of r0 given r and n true#
    ## make all possibilies of true and observed numbers of strains#
    matprobs <- matrix(0,nrow=maxr,ncol=n)#
    dimnames(matprobs) <- list(paste('r',1:maxr,sep=''),paste('r0',1:n,sep=''))
dimnames
matprobs
for (indr in 1:maxr) {  ## loop over number of possible true strains#
      ## peq is the probability of each strain from a single sample#
      seqrloop <- 1:indr #
      peq <- exp(-seqrloop*alpha) / sum(exp(-seqrloop*alpha))#
      ## r0 must be no greater than n samples, no greater than r true strains #
      for (indr0 in 1:min(indr,n)) {  ## loop over number of observed strains#
        ## for each iteration of this loop, #
        ##   the conditional probabilities p(r0|r,n) should add to 1#
        matind <- mkmatind(r=indr,r0=indr0) ; di <- max(1,dim(matind)[1])#
        matposs <- mkmatposs(r0=indr0,n=n) ; dp <- max(1,dim(matposs)[1])#
        ## now need to make one row for every combination or matind and matposs#
        ## combination will be all possible ways to observe indr0 strains#
        ## bigind gives which strains observed#
        bigind <- matrix(as.vector(t(matind)),nrow=di*dp,ncol=indr0,byrow=T)#
        ## bigposs says how many of each of those named in bigind#
        if (dp == 1 ) {   ## placeholder only need if r0=1#
          bigposs <- matrix(matposs,nrow=di,ncol=indr0,byrow=T) #
        }#
        if (dp > 1 ) {#
          bigposs <- matrix(matposs[1,],nrow=di,ncol=indr0,byrow=T)#
          for (pp in 2:dp) {  addon <- matrix(matposs[pp,],nrow=di,ncol=indr0,byrow=T)#
             bigposs <- rbind(bigposs,addon) } }#
        ## the product of each row of pmat is the probability of that combination#
        ##   of strains and numbers of strains making up the observed number#
        ## these first part is the probabilities in order#
        matpeq <- matrix(peq[bigind],nrow=di*dp,ncol=indr0,byrow=F)#
        ## next exponentiate them for the number of times drawn#
        pmat <- (matpeq)^bigposs #
        ## and compute probability for this combo as the product#
        jointprobs <- apply(pmat,1,prod)#
        matprobs[indr,indr0] <- sum(jointprobs)#
      } ## end loop over r0#
    }  ## end loop over r
alpha=0
for (indr in 1:maxr) {  ## loop over number of possible true strains#
      ## peq is the probability of each strain from a single sample#
      seqrloop <- 1:indr #
      peq <- exp(-seqrloop*alpha) / sum(exp(-seqrloop*alpha))#
      ## r0 must be no greater than n samples, no greater than r true strains #
      for (indr0 in 1:min(indr,n)) {  ## loop over number of observed strains#
        ## for each iteration of this loop, #
        ##   the conditional probabilities p(r0|r,n) should add to 1#
        matind <- mkmatind(r=indr,r0=indr0) ; di <- max(1,dim(matind)[1])#
        matposs <- mkmatposs(r0=indr0,n=n) ; dp <- max(1,dim(matposs)[1])#
        ## now need to make one row for every combination or matind and matposs#
        ## combination will be all possible ways to observe indr0 strains#
        ## bigind gives which strains observed#
        bigind <- matrix(as.vector(t(matind)),nrow=di*dp,ncol=indr0,byrow=T)#
        ## bigposs says how many of each of those named in bigind#
        if (dp == 1 ) {   ## placeholder only need if r0=1#
          bigposs <- matrix(matposs,nrow=di,ncol=indr0,byrow=T) #
        }#
        if (dp > 1 ) {#
          bigposs <- matrix(matposs[1,],nrow=di,ncol=indr0,byrow=T)#
          for (pp in 2:dp) {  addon <- matrix(matposs[pp,],nrow=di,ncol=indr0,byrow=T)#
             bigposs <- rbind(bigposs,addon) } }#
        ## the product of each row of pmat is the probability of that combination#
        ##   of strains and numbers of strains making up the observed number#
        ## these first part is the probabilities in order#
        matpeq <- matrix(peq[bigind],nrow=di*dp,ncol=indr0,byrow=F)#
        ## next exponentiate them for the number of times drawn#
        pmat <- (matpeq)^bigposs #
        ## and compute probability for this combo as the product#
        jointprobs <- apply(pmat,1,prod)#
        matprobs[indr,indr0] <- sum(jointprobs)#
      } ## end loop over r0#
    }  ## end loop over r
matprobs
matpeq
pmat
tosum
## now finishing up E step#
    ## recall matprobs is f(r0|r,n)#
    ## so tosum is f(r0,r|n) = f(r0|r,n) * f(r)#
    tosum <- matprobs * (lam^matr / factorial(matr))    #
    ## and condprobs is f(r|r0,n) = f(r0,r|n) / f(r0|n)#
    ##   where f(r0|n) = sum over r of f(r0,r|n) using colSums#
    condprobs <- tosum/(rep(1,maxr)%*%t(colSums(tosum)))
tosum
matr
matprobs
condprobs
matprobs
matind
matposs
bigposs
pmat
jointprobs
addup <- colSums(matr*condprobs)#
    lside <- sum(vecn*addup)#
    rside <- function(lam,N) { N*lam*exp(lam)/(exp(lam)-1) }
addup
lside
rside
lamtest <- rside(lam=lamtry,N=N)#
lamtest
lamcurr <- lamtry[abs(lamtest-lside)==min(abs(lamtest-lside))]#
lamcurr
lam
lamtry
lamtest
lamcurr
lamuse
addup
lside/N
tosum
EM_superinfection_anym(3,(100,10,3),0)
EM_superinfection_anym(3,c(100,10,3),0)
condprobs
sum(condprobs)
log(5)
matr
condprobs
EM_superinfection_anym(3,c(100,10,3),0)
## author = amalia magaret#
## date started = 2016 Sep 08#
## PI = Daniel Reeves#
## objective = run EM algorithm for determining number of true#
##   infections from participants who got n samples each#
## to use#
rm(list=ls())#
source('EM_superinfection_anym.R')
source('superinfection.R')
## here are the parameters you need to choose#
lambda <- 1.4  ## true Poisson parameter for number of infections#
alpha <- 2.2  ## exponential abundance parameter#
n <- 5  ## let there be n samples per person#
## make simulated data#
rinf <- rpois(n=80000,lambda=lambda)#
## make a table of true number of infections#
## need to fill in zeros when rinf not contiguous#
##  so add 1 case for every value bwtn 1 and max in the vector, #
##    and then subtract a count of 1 for each item in the table#
maxr <- max(rinf)#
Nr <- table(c(rinf[rinf>0],1:maxr))-rep(1,maxr)#
truenum <- 1:maxr#
## vectrue is an ordered vector of numbers of strains, #
##    one for each person, with true number of strains for each#
##  or could just sort rinf ##@ all(vectrue==sort(rinf[rinf>0]))#
vectrue <- rep(truenum,Nr)
## now implement measurement error via sampling#
## and for each person, simulate which strain detection for each sampling#
vecobs <- rep(1,Nr[1])  ## will build on this vector#
for (j in 2:maxr) { ## first loop over each true number of infections#
  ## can skip j=1 because can only sample one if one true infection #
  ## also skip if no simulated persons with that number of strains#
  if (Nr[j] > 0) {#
    psamp <- exp(-alpha*(1:j))/sum(exp(-alpha*(1:j)))#
    for (inds in 1:n) { ## then loop over samples for each person#
      detect <- rmultinom(Nr[j],size=1,psamp)#
      ## dim(detect) ## will be length(psamp) rows by Nr[j] columns#
      ## rbind(round(rowMeans(detect),4),round(psamp,4))#
      ## add them up, to see which ones got detected#
      if (inds==1) {keepdet <- detect}  else {keepdet <- keepdet + detect}#
    }  ## at end, if above zero, detected that strain at least once#
    everdet <- 1*(keepdet > 0)  #
    howmanydet <- colSums(everdet)  ## how many unique strains per person#
    vecobs <- c(vecobs,howmanydet)  ## append observed numbers of strains#
  }#
}
## make a matrix of true by simulated numbers of strains#
tabb <- table(vectrue,vecobs)#
probsest <- tabb / rowSums(tabb)#
## can show that this matches matprobs from EM_superinfection_anym.R#
## need to limit to compare, since vecobs may not go as high as n#
##  and also probsest can have a larger number of real strains than maxr#
##@ maxr <- 6 ## use the one from EM_super...#
##@ round(probsest[1:maxr,1:max(vecobs)],4)#
##@ round(matprobs[,1:max(vecobs)],4)#
##@ plot(as.vector(probsest[1:maxr,1:max(vecobs)]),as.vector(matprobs[,1:max(vecobs)]))#
## run to maximize lambda, see if get right one#
Nr0 <- table(c(vecobs,1:n))-rep(1,n)#
tryit <- EM_superinfection_anym(n=n,vecn=Nr0,alpha=alpha)
tryit
tabb
source('run_super_misspec_alpha.R')
source('run_super_misspec_alpha.R')
source('run_super_misspec_alpha.R')
source('run_super_misspec_alpha.R')
source('run_super_misspec_alpha.R')
source('run_super_misspec_alpha.R')
source('run_super_misspec_alpha.R')
filename <- paste("res/lamest.sup",superuse[ll],".alpha",alpha,".ause",alphause[aa],".txt",sep="")
filename
filename
filename <- paste("res/lamest_sup",superuse[ll],"_alpha",alpha,"_ause",alphause[aa],".txt",sep="")
filename
filename <- paste("res/lamest_sup",superuse[ll]*100,"_alpha",alpha,"_ause",alphause[aa],".txt",sep="")
filename
write.table(x=lamest,file=filename,append=T, row.names=F,col.names=F)
source('run_super_misspec_alpha.R')
lamest
if (converged) { write.table(x=lamest,file=filename,append=T, row.names=F,col.names=F) }
converged
anss
anss$conv
source('run_super_misspec_alpha.R')
